---
title: "Data Programming Group Project"
author: "Gina Tedesco, Marvin-Julian Struckmeyer, Ekin Kizildas, Aurora Sterpellone, Estela Moral"
format: 
  revealjs:
    theme: solarized
    scrollable: true
    toc: false
    toc-location: right
    toc-title: Index
    echo: true
---

## Overview

::: {style="font-size: 0.9em;"}

-   Exercise 1

-   Exercise 2

-   Exercise 3

-   Exercise 4

-   Exercise 5

-   Exercise 6

-   Original Exercise 1: Dorling Cartogram

-   Original Exercise 2: Income and Populistic Voting

-   Original Exercise 3: Vox's electoral performance

:::

------------------------------------------------------------------------

## Libraries

```{r}
# Github
library(gert) 

# Data cleaning
library(tidyverse)

# Font setting
library(sysfonts) 
library(showtext) 

# Maps & Geospatial data

library(mapSpain)
library(sf)
library(cartogram)

# Others
library(stringi) 
library(rvest)

# Download Excel data
library(readxl)
```

```{r}
#| include: false

election_data <- readRDS("data/processed/election_data.rds")
surveys <- readRDS("data/processed/surveys.rds")

gdp_data <- read_excel("data/raw/External_GDP_Pop_Data.xlsx", sheet = "GDP")
pop_data <- read_excel("data/raw/External_GDP_Pop_Data.xlsx", sheet = "Population")
```

------------------------------------------------------------------------

## Set up

```{r}
# define a custom theme
theme_presentation <- function() {
  theme_minimal() +
    theme(
      text = element_text(size = 12),
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 14),
      axis.title = element_text(size = 12),
      legend.position = "bottom",
      legend.text = element_text(size = 10),)
  }

# define the colors
party_colors <- c(
  "PSOE" = "#F93D46",
  "PP" = "#41A4F5",
  "VOX" = "#53FF53",
  "ERC" = "#FF9E33",
  "EAJ-PNV" = "#04B82B",
  "OTHER" = "#C0C0C0")

color_palette <-  c(
  "#E69F00",  # orange
  "#56B4E9",  # light blue
  "#009E73",  # green
  "#F0E442",  # yellow
  "#0072B2",  # dark blue
  "#D55E00",  # red
  "#CC79A7",  # pink
  "#999999",  # grey
  "#44AA99",  # teal
  "#332288",  # indigo
  "#AA4499",  # purple
  "#117733")   # forest green
```

------------------------------------------------------------------------

## Data cleaning

```{r}

```

## Exercise 1

```{r}

```

------------------------------------------------------------------------

## Exercise 2

```{r}

```

------------------------------------------------------------------------

## Exercise 3

```{r}

```

------------------------------------------------------------------------

## Exercise 4

```{r}

```

------------------------------------------------------------------------

## Exercise 5

```{r}

```

------------------------------------------------------------------------

## Exercise 6

```{r}

```

------------------------------------------------------------------------

## Original exercise 1: Dorling cartogram

### First steps

```{r}
# Filter election_data

elections_1911 <- election_data |> 
  filter(anno == 2019 & mes == 11) |> 
  select(municipio, cod_mun, codigo_provincia, num_votos, siglas, partido, partido_2)

winners_prov <- elections_1911 |> 
  group_by(codigo_provincia, siglas) |>  
  summarise(votos_totales = sum(num_votos, na.rm = TRUE)) |> 
  slice_max(votos_totales)

# Prepare geospatial data:

provinces <- esp_get_prov() |> 
  mutate(provincia = prov.shortname.en) |> 
  mutate(codigo_provincia = cpro) |> 
  select(provincia, codigo_provincia)

# Set Mercator projection:

provinces <- st_transform(provinces, 3857)

# Population data:

pop_prov <- mapSpain::pobmun19 |> 
  rename(codigo_provincia = cpro) |> 
  group_by(codigo_provincia) |> 
  summarise(n_pop = sum(pob19))

# Join all dataframes:

pop_prov <- provinces |> 
  left_join(pop_prov, by = "codigo_provincia") |> 
  left_join(winners_prov, by = "codigo_provincia")
```

------------------------------------------------------------------------

### Create the cartogram

```{r}
pop_prov_cartog <- cartogram_dorling(pop_prov, 
                                     weight = "n_pop")

pop_prov_cartog <- ggplot(pop_prov_cartog) +
  geom_sf(aes(fill = siglas)) +
  scale_fill_manual(values = party_colors,
                    name = "Party",
                    breaks = c("PSOE", "PP", "VOX", "ERC", "EAJ-PNV", "OTHER")) +
  theme_void() +
  labs(title = "2019 November Elections: Most voted party by province",
       subtitle = "(The size of each circle represents the population of each province)") +
  theme(plot.title = element_text(face = "bold",
                                  margin = unit(c(0.6, 0, 0.2, 0), "cm"),
                                  size = 18,
                                  family = "rob_cond"),
        plot.subtitle = element_text(family = "rob_cond",
                                     size = 14),
        legend.title = element_text(face = "bold",
                                    family = "rob_cond", 
                                    size = 15),
        legend.text = element_text(family = "rob_cond", 
                                    size = 12))
```

------------------------------------------------------------------------

```{r}
#| echo: false
#| fig-width: 12
#| fig-height: 8

pop_prov_cartog
```

------------------------------------------------------------------------

## Original exercise 2: Parliament plot (?)

```{r}

```

------------------------------------------------------------------------

## Original exercise 2: Income and Populistic Voting

### First steps: Data download and wrangling

```{r}
# source: REGDATA_v70_55_23.xlsx from :
# https://www.bbvaresearch.com/en/publicaciones/spain-long-series-of-regional-
# economic-and-demographic-aggregates-2023-update/

# convert both datasets to long format
gdp_long <- gdp_data |> 
  pivot_longer(
    cols = -'...1',
    names_to = "year",
    values_to = "gdp") |> 
  rename(region = '...1')

pop_long <- pop_data |> 
  pivot_longer(
    cols = -'...1',
    names_to = "year",
    values_to = "population" ) |> 
  rename(region = '...1')

# join GDP and population data
combined_data <- gdp_long |> 
  left_join(pop_long, by = c("region", "year"))

# calculate GDP per capita
gdp_per_capita <- combined_data |> 
  mutate(gdp_per_capita = gdp / population) |> 
  arrange(region, year)

# calculate growth rates (1999-2019)
growth_rates <- gdp_per_capita |> 
  group_by(region) |> 
  summarize(
    gdp_per_capita_1999 = first(gdp_per_capita),
    gdp_per_capita_2019 = last(gdp_per_capita),
    total_growth = (gdp_per_capita_2019 / gdp_per_capita_1999 - 1) * 100) |> 
  arrange(desc(total_growth))

# calculate national average growth
national_avg_growth <- mean(growth_rates$total_growth)

# add relative growth compared to national average
growth_rates <- growth_rates |> 
  mutate(
    relative_growth = total_growth - national_avg_growth,
    growth_category = if_else(relative_growth >= 0, "Above Average", "Below Average"))

# view results
print("GDP per capita growth rates by region (1999-2019):")
print(growth_rates)

print(paste("National average growth rate:", round(national_avg_growth, 2), "%"))

```

------------------------------------------------------------------------

### Next: Get VOX election results and join

```{r}
# calculate VOX results by CCAA for November 2019
vox_results_2019 <- election_data |> 
  filter(anno == 2019, mes == 11) |> 
  mutate(
    party_group = case_when(
      partido_2 == "VOX" ~ "VOX",
      TRUE ~ "OTHER")) |> 
  group_by(codigo_ccaa, party_group) |> 
  summarise(
    votes = sum(num_votos, na.rm = TRUE),
    .groups = 'drop') |> 
  pivot_wider(
    names_from = party_group,
    values_from = votes,
    values_fill = 0) |> 
  mutate(
    total_votes = VOX + OTHER,
    vox_percentage = (VOX / total_votes) * 100)

# create lookup table with official CCAA codes
# this is based on https://www.ine.es/en/daco/daco42/codmun/cod_ccaa_en.htm
ccaa_lookup <- tibble(
  codigo_ccaa = c(paste0("0", 1:9), as.character(10:17), "18", "19"),
  region = c("AND", "ARA", "AST", "BAL", "CAN", "CANT", "CYL", "CLM", 
             "CAT", "VAL", "EXT", "GAL", "MAD", "MUR", "NAV", "PV", 
             "RIO", "CyMel", "CyMel"))

# join CCAA codes with results and combine Ceuta and Melilla
vox_results_2019_named <- vox_results_2019 |> 
  left_join(ccaa_lookup, by = "codigo_ccaa") |> 
  group_by(region) |> 
  summarise(
    VOX = sum(VOX),
    OTHER = sum(OTHER),
    total_votes = sum(total_votes),
    vox_percentage = (sum(VOX) / sum(total_votes)) * 100) |> 
  arrange(region)

# now join with GDP growth data
combined_analysis <- growth_rates |> 
  filter(region != "total") |> # Remove the 'total' row
  left_join(vox_results_2019_named, by = "region") |> 
  select(region, relative_growth, vox_percentage, growth_category)

# print combined results
print("\nCombined GDP growth and VOX support analysis:")
print(combined_analysis)
```

------------------------------------------------------------------------

### Analysis and scatterplot

```{r}
# calculate correlation (excluding NA values)
correlation <- cor(combined_analysis$relative_growth, 
                   combined_analysis$vox_percentage,
                   use = "complete.obs")  # this will exclude NA values
print(paste("\nCorrelation between relative GDP growth and VOX support:", round(correlation, 3)))

# create scatter plot
scatter_plot_1 <- ggplot(combined_analysis, aes(x = relative_growth, y = vox_percentage)) +
  geom_point(aes(color = growth_category), size = 3) +
  geom_text(aes(label = region), vjust = -0.5, size = 3) +
  geom_smooth(method = "lm", color = "red", linetype = "dashed", se = FALSE) +
  labs(
    title = "Relationship between Economic Growth and VOX Support",
    subtitle = "By Autonomous Community (1999-2019)",
    x = "Relative GDP per Capita Growth (%)",
    y = "VOX Vote Share (%)",
    color = "Growth Category"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold"))
```

------------------------------------------------------------------------

```{r}
#| echo: false
#| fig-width: 12
#| fig-height: 8

scatter_plot_1
```

------------------------------------------------------------------------

## Original Exercise 3: Vox's electoral performance

### Exercise:

Analyze VOX's electoral performance in the Nov 2019 general election by studying
(1) how voter turnout relates to VOX's electoral success across municipalities, 
(2) visualising the geographic concentration in the support of Vox, 
and (3) studying electoral fragmentation.

------------------------------------------------------------------------

### Analysing how voter turnout relates to Vox's electoral success

```{r}
# first, let's create municipality_summary for November 2019 (using both month and year)
municipality_summary_2019 <- election_data |> 
  filter(anno == 2019, mes == 11) |>   # specifying November 2019
  group_by(municipio) |> 
  slice(1) |> 
  summarise(
    censo = censo,
    total_votes = votos_candidaturas + votos_blancos + votos_nulos,
    valid_votes = votos_candidaturas,
    turnout = (total_votes / censo) * 100) |> 
  filter(!is.na(turnout), turnout <= 100, turnout > 0)

# then calculate party votes for the same election
party_votes_2019 <- election_data |> 
  filter(anno == 2019, mes == 11) |>   # again, specifying November 2019
  mutate(
    party_group = case_when(
      partido_2 == "VOX" ~ "VOX",
      TRUE ~ "OTHER")) |> 
  group_by(municipio, party_group) |> 
  summarise(
    votes = sum(num_votos, na.rm = TRUE),
    .groups = 'drop') |> 
  pivot_wider(
    names_from = party_group,
    values_from = votes,
    values_fill = 0)

# join the two objects
final_analysis <- municipality_summary_2019 |> 
  left_join(party_votes_2019, by = "municipio") |> 
  mutate(
    vox_share = (VOX / valid_votes) * 100) |> 
  select(municipio, censo, turnout, vox_share)

# calculate the correlation
cor(final_analysis$turnout, final_analysis$vox_share)

  # we tested for different sizes of municipalities by adding a population
  # threshold; the correlations were more or less the same

# visualise
turnout_vox_share_plot <- ggplot(final_analysis) +
  geom_point(aes(x = turnout, y = vox_share), alpha = 0.3, color = "#52BE80", size = 2) +
  geom_smooth(aes(x = turnout, y = vox_share), method = "lm", se = TRUE, color = "#52BE80") +
  labs(
    title = "Relationship between Turnout and VOX Vote Share (November 2019)",
    subtitle = "Analysis by Municipality",
    x = "Voter Turnout (%)",
    y = "VOX Vote Share (%)"
  ) +
  theme_presentation()
```

------------------------------------------------------------------------

```{r}
#| echo: false
#| fig-width: 12
#| fig-height: 8

turnout_vox_share_plot
```

------------------------------------------------------------------------

### Visualising the geographic concentration in the support of Vox

```{r}
regional_analysis <- election_data |> 
  filter(anno == 2019, mes == 11) |> 
  group_by(codigo_provincia) |>  
  summarise(total_votes = sum(num_votos, na.rm = TRUE), 
            vox_share = sum(num_votos[partido_2 == "VOX"], na.rm = TRUE) / total_votes * 100)

# get geospatial data for Spanish provinces
provinces <- esp_get_prov() |> 
  mutate(
    provincia = prov.shortname.en,
    codigo_provincia = as.character(cpro)) |> 
  select(provincia, codigo_provincia)

# transform to Mercator projection
provinces <- st_transform(provinces, 3857)

# get population data
pop_prov <- mapSpain::pobmun19 |> 
  rename(codigo_provincia = cpro) |> 
  mutate(codigo_provincia = as.character(codigo_provincia)) |> 
  group_by(codigo_provincia) |> 
  summarise(n_pop = sum(pob19))

# join all data
final_data <- provinces %>%
  left_join(pop_prov, by = "codigo_provincia") %>%
  left_join(regional_analysis, by = "codigo_provincia")

# set up font
sysfonts::font_add_google("Roboto Condensed", family = "rob_cond")
showtext::showtext_auto()

# create color palette for VOX vote share
vox_colors <- colorRampPalette(c("#FFFFFF", "#53FF53"))(5)

# create Dorling cartogram
cartogram_plot <- cartogram_dorling(final_data, weight = "n_pop")

# create the final plot
cartogram_vox_plot <- ggplot(cartogram_plot) +
  geom_sf(aes(fill = vox_share)) +
  scale_fill_gradientn(
    colors = vox_colors,
    name = "VOX Vote Share (%)",
    limits = c(0, max(regional_analysis$vox_share)),
    breaks = seq(0, max(regional_analysis$vox_share), length.out = 5),
    labels = scales::label_number(accuracy = 0.1)) +
  theme_void() +
  labs(
    title = "VOX Vote Share by Province (November 2019)",
    subtitle = "Circle size represents province population") +
  theme(
    plot.title = element_text(
      face = "bold",
      margin = unit(c(0.6, 0, 0.2, 0), "cm"),
      size = 18,
      family = "rob_cond"),
    plot.subtitle = element_text(
      family = "rob_cond",
      size = 14),
    legend.title = element_text(
      face = "bold",
      family = "rob_cond",
      size = 15),
    legend.text = element_text(
      family = "rob_cond",
      size = 12))
```

------------------------------------------------------------------------

```{r}
#| echo: false
#| fig-width: 12
#| fig-height: 8

cartorgram_vox_plot
```

------------------------------------------------------------------------

### Studying electoral fragmentation

```{r}
fragmentation_analysis <- election_data |> 
  filter(anno == 2019, mes == 11) |> 
  group_by(municipio) |> 
  summarise(
    total_votes = sum(num_votos, na.rm = TRUE),
    vox_share = sum(num_votos[partido_2 == "VOX"], na.rm = TRUE) / total_votes * 100,
    pp_share = sum(num_votos[partido_2 == "PARTIDO POPULAR"], na.rm = TRUE) / total_votes * 100,
    psoe_share = sum(num_votos[partido_2 == "PARTIDO SOCIALISTA OBRERO ESPAÃ‘OL"], na.rm = TRUE) / total_votes * 100,
    traditional_share = pp_share + psoe_share,  # combined share of traditional parties
    effective_parties = 1 / sum((num_votos/total_votes)^2, na.rm = TRUE))

# first visualisation: scatter plot of VOX share vs effective number of parties
fragmentation_analysis_1 <- ggplot(fragmentation_analysis) +
  geom_point(aes(x = effective_parties, y = vox_share), 
             alpha = 0.4, color = "#52BE80") +
  geom_smooth(aes(x = effective_parties, y = vox_share), 
              method = "lm", color = "#2E86C1") +
  labs(
    title = "VOX Support vs Electoral Fragmentation",
    subtitle = "November 2019 Elections",
    x = "Effective Number of Parties",
    y = "VOX Vote Share (%)"
  ) +
  theme_presentation()

# second visualisation: scatter plot with traditional party share
fragmentation_analysis_2 <- ggplot(fragmentation_analysis) +
  geom_point(aes(x = traditional_share, y = vox_share), 
             alpha = 0.4, color = "#E74C3C") +
  geom_smooth(aes(x = traditional_share, y = vox_share), 
              method = "lm", color = "#8E44AD") +
  labs(
    title = "VOX Support vs Traditional Party Support",
    subtitle = "November 2019 Elections",
    x = "Combined PP + PSOE Vote Share (%)",
    y = "VOX Vote Share (%)") +
  theme_presentation()

# calculate correlations
cor_analysis <- fragmentation_analysis |> 
  summarise(
    cor_fragmentation = cor(effective_parties, vox_share, use = "complete.obs"),
    cor_traditional = cor(traditional_share, vox_share, use = "complete.obs"))

print("Correlation Analysis:")
print(cor_analysis)
```

------------------------------------------------------------------------

```{r}
#| echo: false
#| fig-width: 12
#| fig-height: 8
fragmentation_analysis_1
```

------------------------------------------------------------------------

```{r}
#| echo: false
#| fig-width: 12
#| fig-height: 8
fragmentation_analysis_2
```

